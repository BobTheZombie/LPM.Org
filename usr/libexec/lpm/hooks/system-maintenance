#!/usr/bin/env python3
"""Run post-transaction maintenance tasks for LPM."""

from __future__ import annotations

import os
import sqlite3
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import Iterable, List


def _find_lpm() -> str | None:
    return shutil.which("lpm")


_STATE_DIR_FALLBACK = Path("/var/lib/lpm")
_STATE_DB_NAME = "state.db"
_RECENT_WINDOW_SECONDS = 30


def _resolve_state_dir(root: str) -> Path:
    env_dir = os.environ.get("LPM_STATE_DIR")
    if env_dir:
        return Path(env_dir)
    root_path = Path(root)
    if root_path not in {Path(""), Path("/")}:
        return root_path / "var" / "lib" / "lpm"
    return _STATE_DIR_FALLBACK


def _recent_history_actions(state_dir: Path, window: int = _RECENT_WINDOW_SECONDS) -> set[str]:
    if window <= 0:
        return set()
    db_path = state_dir / _STATE_DB_NAME
    try:
        conn = sqlite3.connect(str(db_path))
    except sqlite3.Error:
        return set()
    try:
        cutoff = int(time.time()) - window
        rows = conn.execute("SELECT action FROM history WHERE ts >= ?", (cutoff,))
        actions = {str(row[0]).strip().lower() for row in rows if row and row[0]}
        return actions
    except sqlite3.Error:
        return set()
    finally:
        conn.close()


def _should_skip_autoremove(actions: set[str]) -> bool:
    if not actions:
        return False

    # If the transaction explicitly removed packages, do not immediately run
    # autoremove.  In practice this can cascade into removing dependencies that
    # the user did not intend to purge (see `lpm removepkg` invocations).
    if "remove" in actions:
        return True

    # Likewise, skip autoremove for transactions that *only* install new
    # packages.  This mirrors the previous behaviour that avoided cleaning up
    # packages right after they were installed.
    if actions == {"install"}:
        return True

    return False


def _build_tasks(lpm_path: str, root: str, *, skip_autoremove: bool = False) -> List[List[str]]:
    tasks: List[List[str]] = []
    if not skip_autoremove:
        tasks.append([lpm_path, "autoremove", "--root", root])
    if root in {"", "/"}:
        tasks.append([lpm_path, "snapshots", "--prune"])
        tasks.append([lpm_path, "clean"])
    return tasks


def _run_tasks(commands: Iterable[List[str]], env: dict[str, str]) -> None:
    for argv in commands:
        try:
            subprocess.run(argv, check=False, env=env)
        except FileNotFoundError:
            # If a command disappears mid-transaction, abort further runs.
            return
        except Exception as exc:  # pragma: no cover - best effort logging only
            print(
                f"[lpm-maintenance] failed to run {' '.join(argv)}: {exc}",
                file=sys.stderr,
            )


def main() -> None:
    if os.environ.get("LPM_SKIP_MAINTENANCE") == "1":
        return

    lpm_path = _find_lpm()
    if not lpm_path:
        return

    root = os.environ.get("LPM_ROOT", "/") or "/"
    env = dict(os.environ)
    env["LPM_SKIP_MAINTENANCE"] = "1"

    state_dir = _resolve_state_dir(root)
    recent_actions = _recent_history_actions(state_dir)
    skip_autoremove = _should_skip_autoremove(recent_actions)

    tasks = _build_tasks(lpm_path, root, skip_autoremove=skip_autoremove)
    _run_tasks(tasks, env)


if __name__ == "__main__":
    main()
